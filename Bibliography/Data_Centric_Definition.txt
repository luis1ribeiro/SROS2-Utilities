Distributed systems work by sending information between otherwise independent applications. Traditionally, that communication is done by passing messages between the various nodes. This "message-centric" approach takes many forms, from simple direct transmissions to more complex message queue and transactional systems. All have a common premise: the unit of information exchange is the message itself. The infrastructure's role is to ensure that messages get to their intended recipients.

Recently, another paradigm is becoming popular. In this approach, the distributed infrastructure takes more responsibility; it offers to the distributed system a single version of "truth". The fundamental unit of communication is a data-object value; the infrastructure has done its job not when a message is delivered, but when all nodes have the correct understanding of that value. Because the focus is on the data itself, this is termed "data-centric" infrastructure.


-- Message-Centric --
The important common property for this discussion is that these technologies consider the message itself to be the means of interaction. The infrastructure is unaware of the message contents. With a message-centric approach, developers write applications that send messages between participants.

 -- Data-Centric --
Data centricity, by contrast, makes the data the means of interaction. A data centric infrastructure must define the data it manages. Then, the infrastructure imposes rules that determine how data is structured, when data is changed, and how it is accessed. There is a notion of a "global data space", where data values, in known structures, are exchanged. The infrastructure is aware of the contents. With a data-centric approach, developers write applications that read and update entries in this data space.
Like a database, data-centric middleware imposes known structure on the transmitted data. The infrastructure, and all its associated tools and services, can now access the data through CRUD-like operations. Clear rules govern access to the data, how data in the system changes, and when participants get updates. As in databases, this accessible source of consistent truth greatly eases system integration. Thus, the data-centric distributed "databus" does for data in motion what the structured database does for data at rest.


!! Simple thermometer example !!

Message-centric systems usually send "verbs", while data-centric systems update "nouns". For instance, consider a simple system that reads a thermometer and communicates temperature. With message-centric verbs, the thermometer would send messages like "update the temperature for sensor #1221 to 27". The middleware doesn't know this; there is no system notion of sensor ID or temperature. The applications must understand that these messages tell them to change their notion of temperature. The application developer must define functions and parameters and take the right actions.
The middleware has no notion of the meaning of messages. It can therefore make no judgment about the importance of any particular message in the stream, regardless of what might come before or after it.
This implies that the application, as a whole, must manage "truth". Every application reads the messages and ascertains its own version of truth. The application code manages the distributed state.

With data-centric nouns, the sending application sets the value of the known global data object "temperature of sensor #1221" to "27". The middleware knows what that means and distributes the information to nodes that need it. Receiving applications read the "temperature" value from the object, likely upon notification that it has changed.
Data-centric middleware disseminates and manages state. To do this, the middleware must know the data schemas, treat instances of data as known objects, and attach behaviors to the data, not to the flow.
This means that the infrastructure is responsible for providing a consistent view of "truth". In a dynamic distributed system, it's not simple to have "absolute" truth, but the middleware can be crisp about exactly how reliable the information is, how old it is, how many past versions are saved, what delivery guarantees there are, what happens if a producer fails, etc. These "Quality of Service" (QoS) settings specify how to manage the state of each data item.

This difference may not be obvious until you consider what happens, for instance, when an application joins after missing 50 updates to the value of sensor #1221 and 30 to sensor #1222. The message centric system will send all 80 updates, and the receiver must then process each one. The data-centric middleware distributes the data space, and then simply allows the late joiner to read the latest value of each object, only two in this case. Both end up with the right value, but the network traffic and application processing is very different.


-- How important is controlled state? --
Overall, a distributed application has a lot of state. If the infrastructure doesn't manage state, then every application must store and maintain its own state. Unmanaged state leads quickly to inconsistency. This is brittle; inconsistent systems break in many ways. With a data-centric approach, state is managed, redundant producer failover is natural, and multiple consumers can easily access consistent state. In many ways, a data-centric design is easier to make reliable and available.

However, delegating state control to the infrastructure has cost. The system needs a shared data model, so data schema and properties must be globally agreed (or later mediated, a topic beyond this treatment). Messaging systems can be much more lax in their upfront data definitions. Keeping state control in the applications, while an added burden, also gives application developers more design flexibility.



!! LINK: https://www.electronicdesign.com/technologies/embedded-revolution/article/21795976/whats-the-difference-between-message-centric-and-data-centric-middleware
