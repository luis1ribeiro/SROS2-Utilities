-- The ROS_DOMAIN_ID --

As explained elsewhere, the default middleware that ROS 2 uses for communication is DDS. In DDS, the primary mechanism for having different logical networks share a physical network is known as the Domain ID.
ROS 2 nodes on the same domain can freely discover and send messages to each other, while ROS 2 nodes on different domains cannot.
The domain ID is used by DDS to compute the UDP ports that will be used for discovery and communication.


-- About different ROS 2 DDS/RTPS vendors --

ROS 2 is built on top of DDS/RTPS as its middleware, which provides discovery, serialization and transportation.
In summary, DDS is an end-to-end middleware that provides features which are relevant to ROS systems, such as distributed discovery (not centralized like in ROS 1) and control over different “Quality of Service” options for the transportation.

ROS 2 supports multiple DDS/RTPS implementations because it is not necessarily “one size fits all” when it comes to choosing a vendor/implementation.
There are many factors you might consider while choosing a middleware implementation: logistical considerations like the license, or technical considerations like platform availability, or computation footprint.
Vendors may provide more than one DDS or RTPS implementation targeted at meeting different needs.


-- About logging and logger configuration --

Log messages have a severity level associated with them: DEBUG, INFO, WARN, ERROR or FATAL, in ascending order.
A logger will only process log messages with severity at or higher than a specified level chosen for the logger.

Each node (in rclcpp and rclpy) has a logger associated with it that automatically includes the node’s name and namespace.
If the node’s name is externally remapped to something other than what is defined in the source code, it will be reflected in the logger name.
Non-node loggers can also be created that use a specific name.

Logger names represent a hierarchy.
If the level of a logger named “abc.def” is unset, it will defer to the level of its parent named “abc”, and if that level is also unset, the default logger level will be used.
When the level of logger “abc” is changed, all of its descendants (e.g. “abc.def”, “abc.ghi.jkl”) will have their level impacted unless their level has been explicitly set.


-- About Quality of Service settings --

ROS 2 offers a rich variety of Quality of Service (QoS) policies that allow you to tune communication between nodes.
With the right set of Quality of Service policies, ROS 2 can be as reliable as TCP or as best-effort as UDP, with many, many possible states in between.
Unlike ROS 1, which primarily only supported TCP, ROS 2 benefits from the flexibility of the underlying DDS transport in environments with lossy wireless networks where a “best effort” policy would be more suitable, or in real-time computing systems where the right Quality of Service profile is needed to meet deadlines.

A QoS profile can be applied independently to each instance of the aforementioned entities, but if different profiles are used, it is possible that they will be incompatible, preventing the delivery of messages.
Profiles allow developers to focus on their applications without worrying about every QoS setting possible. A QoS profile defines a set of policies that are expected to go well together for a particular use case.

QoS profile compatibility is determined based on a “Request vs Offered” model.
(!) Subscriptions request a QoS profile that is the “minimum quality” that it is willing to accept, and publishers offer a QoS profile that is the “maximum quality” that it is able to provide. Connections are only made if every policy of the requested QoS profile is not more stringent than that of the offered QoS profile.
Multiple subscriptions can be connected to a single publisher simultaneously even if their requested QoS profiles are different.
The compatibility between a publisher and a subscription is unaffected by the presence of other publishers and subscriptions.

Historically in ROS 1, any publisher and subscriber with the same message type on the same topic would be connected.
The possibility of incompatible requested and offered QoS profiles is something new to be aware of when using ROS 2.


-- About ROS 2 interfaces --

ROS applications typically communicate through interfaces of one of three types: messages, services and actions. ROS 2 uses a simplified description language, the interface definition language (IDL), to describe these interfaces.
This description makes it easy for ROS tools to automatically generate source code for the interface type in several target languages.

* msg: .msg files are simple text files that describe the fields of a ROS message. They are used to generate source code for messages in different languages.
* srv: .srv files describe a service. They are composed of two parts: a request and a response. The request and response are message declarations.
* action: .action files describe actions. They are composed of three parts: a goal, a result, and feedback. Each part is a message declaration itself.

Default Values, Constant Values, etc.


-- About parameters in ROS 2 --

ROS parameters are associated with ROS nodes. Parameters are used to externally configure nodes at runtime (and during runtime).
The lifetime of a parameter is tied to the lifetime of the node (though the node could implement some sort of persistence to reload values after restart).

-- MORE LINKS --
 .  http://wiki.ros.org/ROS/Master API.
 .  http://wiki.ros.org/ros control.
 .  https://github.com/ros2/ros2/wiki.
