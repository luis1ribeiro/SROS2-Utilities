\documentclass[11pt,a4paper]{report}%especifica o tipo de documento que tenciona escrever: carta, artigo, relatório... neste caso é um relatório
% [11pt,a4paper] Define o tamanho principal das letras do documento. caso não especifique uma delas, é assumido 10pt
% a4paper -- Define o tamanho do papel.

\usepackage[english]{babel}%Babel -- irá activar automaticamente as regras apropriadas de hifenização para a língua todo o
                                   %-- o texto gerado é automaticamente traduzido para Português.
                                   %  Por exemplo, “chapter” irá passar a “capítulo”, “table of contents” a “conteúdo”.
                                   % portuges -- específica para o Português.
\usepackage[utf8]{inputenc} % define o encoding usado texto fonte (input)--usual "utf8" ou "latin1

\usepackage{graphicx} %permite incluir graficos, tabelas, figuras
\usepackage{url} % para utilizar o comando \url{}
\usepackage{enumerate} %permite escolher, nas listas enumeradas, se os iems sao marcados com letras ou numeros-romanos em vez de numeracao normal

\usepackage{hyperref}

%\usepackage{apalike} % gerar biliografia no estilo 'named' (apalike)

\usepackage{color} % Para escrever em cores

\usepackage{multirow} %tabelas com multilinhas
\usepackage{array} %formatação especial de tabelas em array

\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage{titlesec, blindtext, color}
\definecolor{gray75}{gray}{0.75}
\newcommand{\hsp}{\hspace{20pt}}
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}
\usepackage{tabularx}


\usepackage{minted}
\usepackage{tcolorbox}

%Exemplos de fontes -- nao e vulgar mudar o tipo de fonte
%\usepackage{tgbonum} % Fonte de letra: TEX Gyre Bonum
%\usepackage{lmodern} % Fonte de letra: Latin Modern Sans Serif
%\usepackage{helvet}  % Fonte de letra: Helvetica
%\usepackage{charter} % Fonte de letra:Charter

\definecolor{saddlebrown}{rgb}{0.55, 0.27, 0.07} % para definir uma nova cor, neste caso 'saddlebrown'
\newcommand\tab[1][1cm]{\hspace*{#1}}

\usepackage{listings}  % para utilizar blocos de texto verbatim no estilo 'listings'
%paramerização mais vulgar dos blocos LISTING - GENERAL
\lstset{
	basicstyle=\small, %o tamanho das fontes que são usadas para o código
	numbers=left, % onde colocar a numeração da linha
	numberstyle=\tiny, %o tamanho das fontes que são usadas para a numeração da linha
	numbersep=5pt, %distancia entre a numeração da linha e o codigo
	breaklines=true, %define quebra automática de linha
    frame=tB,  % caixa a volta do codigo
	mathescape=true, %habilita o modo matemático
	escapeinside={(*@}{@*)}, % se escrever isto  aceita tudo o que esta dentro das marcas e nao altera
	gobble=8, tabsize=4
}
%
%\lstset{ %
%	language=Java,							% choose the language of the code
%	basicstyle=\ttfamily\footnotesize,		% the size of the fonts that are used for the code
%	keywordstyle=\bfseries,					% set the keyword style
%	%numbers=left,							% where to put the line-numbers
%	numberstyle=\scriptsize,				% the size of the fonts that are used for the line-numbers
%	stepnumber=2,							% the step between two line-numbers. If it's 1 each line
%											% will be numbered
%	numbersep=5pt,							% how far the line-numbers are from the code
%	backgroundcolor=\color{white},			% choose the background color. You must add \usepackage{color}
%	showspaces=false,						% show spaces adding particular underscores
%	showstringspaces=false,					% underline spaces within strings
%	showtabs=false,							% show tabs within strings adding particular underscores
%	frame=none,								% adds a frame around the code
%	%abovecaptionskip=-.8em,
%	%belowcaptionskip=.7em,
%	tabsize=2,								% sets default tabsize to 2 spaces
%	captionpos=b,							% sets the caption-position to bottom
%	breaklines=true,						% sets automatic line breaking
%	breakatwhitespace=false,				% sets if automatic breaks should only happen at whitespace
%	title=\lstname,							% show the filename of files included with \lstinputlisting;
%											% also try caption instead of title
%	escapeinside={\%*}{*)},					% if you want to add a comment within your code
%	morekeywords={*,...}					% if you want to add more keywords to the set
%}

\usepackage{xspace} % deteta se a seguir a palavra tem uma palavra ou um sinal de pontuaçao se tiver uma palavra da espaço, se for um sinal de pontuaçao nao da espaço

\parindent=0pt %espaço a deixar para fazer a  indentação da primeira linha após um parágrafo
\parskip=2pt % espaço entre o parágrafo e o texto anterior

\setlength{\oddsidemargin}{-1cm} %espaço entre o texto e a margem
\setlength{\textwidth}{18cm} %Comprimento do texto na pagina
\setlength{\headsep}{-1cm} %espaço entre o texto e o cabeçalho
\setlength{\textheight}{23cm} %altura do texto na pagina

%\input{LPgeneralDefintions} %permite ler de um ficheiro de texto externo mais definições
%\lhead{lado esquerdo do cabeçalho}
%\chead{parte central do cabeçalho}
%\rhead{lado direito do cabeçalho}
%\lfoot{lado esquerdo do rodapé}
%\cfoot{parte central do rodapé}
%\rfoot{lado direito do rodapé}

\begin{document} % corpo do documento
%\maketitle % apresentar titulo, autor e data


\begin{titlepage}
    \centering
    {\Large
        \huge Thesis Dissertation\\
    }

    \Large Formalizing ROS2 security configuration with Alloy

    \vfill
    \begin{center}\large

        \begin{tabular}{ll}
            \textbf{a85954} & \textbf{Luís Ribeiro}
        \end{tabular}

    \end{center}
    \includegraphics[width=8cm]{images/UM.jpg} % also works with logo.pdf
    \begin{center}
        \large Mestrado em Engenharia Informática\\
            Universidade do Minho

    \end{center}

    \vfill
    \vfill
    \vfill
\end{titlepage}

\newpage
\tableofcontents{}
\newpage

%\let\clearpage\relax
%\titlespacing*{\chapter}{pt}{-20pt}{20pt}
%\chapter{Introduction}

%This assignment revolves around the Travelling Salesman Problem (TSP). This problem is one of those that can be easily formulated but whose answer cannot be efficiently obtained. For that reason, our task in this assignment aims to model and analyse different variants of TSP via \textbf{monads} and their facilities.\\
%Every exercise has its own section, so that


\titlespacing*{\chapter}{pt}{-20pt}{20pt}
\chapter{Robotic Operating System}

    This dissertation focus on the exploration of potential non-studied properties related to the security of the robotic world. Therefore, before taking consideration about security matters, \textbf{R}obotic \textbf{O}perating \textbf{S}ystem, known simply as \textbf{ROS}, must be introduced.

    \section{Context}

        Robots have emerged into our world as they are used routinely to perform quests done traditionally by human beings. The usage of robots brings increased productivity, safety and more manufacturing production work back to developed countries. Robotics is already the key driver of competitiveness and flexibility in large scale manufacturing industries.

        When it comes to writing software code for robot applications, multiple aspects must be considered properly, as the complexity of robotics is continuously growing. Robots tend to be designed for a particular purpose, resulting in a wide variety of hardware combined, consequently making already written software code extremely difficult to understand and implement. Typically, code perception and reasoning are way to complex for any single programmer, when abstraction strategies are not taking into account. Even though, many robotics researchers have previously created frameworks to deal with these problems, simplifying complexity issues by providing rapid prototyping, they tend to not scale to feature a wide community of robotics programmers. ROS aims to solve this concern, by providing a modular package-based framework, designed to be built upon by robot software developers. Their software can then be utilized by a variety of platforms and applications.

        At first it may seem that its being dealt with an Operating System, but its actually a open-source framework, composed by software libraries and tools with the aim of helping build robot applications easily, without the need of building it from scratch. ROS was designed to be flexible, since working with robots requires experimentation, given the variety of different hardware and software. This flexibility enables the combination between existing components with new ones.

        % The need for ROS - a framework that had a different approach (LER ROS_open_source.pdf)

        \subsection{Evolving into ROS2}

            ROS provides a distributed architecture that operates as a publish-subscribe service to distribute data among nodes in a system. The first version of ROS, namely ROS1, uses a custom serialization format, a custom transport protocol as well as a custom central discovery mechanism, meaning that the interface layer, called the communication middleware, was implemented by them.

            The main ideia behind having implemented their own middleware is that there was a need to have a \textbf{Master node}, that controlled every aspect of the communication establishment, acting as DNS server to the nodes that want to exchange information. Before running any node, a ROS Master node must be initialized, in order to retrieve information to the node that is running. Also, the location of the ROS Master must be addressable by the network nodes. The parameters, which in ROS provides useful runtime information about nodes, was also handled by the ROS Master. This \textbf{centralization} fits the purposes of a research tool, because of the vast capabilities that is controlled by the master, but does not scale well, making it unsuitable for safety-critical and real-time systems. It is considered a performance bottleneck because everything has to go through the master. If the master goes down then the whole system goes down, representing a single-point of failure.

            \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.5\linewidth]{images/former-ros1-architecture.png}
            \end{figure}

            This lead to the creation of \textbf{ROS2}, which continues to provide a simple, uniform message passing interface to allow components to communicate with each other, now implemented using the Data Distribution Service (DDS) communication protocol as middleware. This means that there is no need to implement a master, making the system fully distributed. The discovery process between nodes is distributed and guaranteed by DDS, giving theses nodes the capacity to discover other nodes. Considering that there is no ROS Master implemented, the approach when dealing with the parameters also changed. Instead of having a global parameter server, in ROS2 each node declares and manages its own parameters. All these aspects related to ROS2 will be later discussed.



        \subsection{Data Distribution Service: A Data-Centric Approach}

            \textbf{Data Distributed System}, known as DDS, is a middleware Object Management Group (OMG) standard, directly addressing data communication between nodes that belong to a \textit{publish-subscribe} communication architecture, for real-time and embedded systems, that relies on a data-centric approach.

            A middleware, such as DDS, is the software layer that comes between the \textbf{Platform layer}, where configuration about operating systems and network transport is covered, and the \textbf{Application layer}. By that, developers can mainly focus on their applications purposes, instead of concerning about information passing between layers.

            \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.5\linewidth]{images/middleware.png}
            \end{figure}

            Usually, middlewares are implemented by distributed systems, that rely on timing-measures and efficiency when it comes to data-delivering between nodes. DDS aims to ease the complexity of building their own middleware. Complex network configuration, communication establishment, data sharing and low-level details are handled by DDS. The specification of \textbf{Quality of Service} (QoS) parameters is a great feature, because of the versatility that each one offers to the system. Re-sending messages that did not reach their destination, multicast updates, dynamic resizing of messages, version tracking and many other parameters can be useful to satisfy some system requirements.

            When it comes to easing the communication establishment, DDS features a \textbf{Dynamic Discovery} within nodes, by providing automatic discovery between endpoints and useful information about them. Network configuration is also guaranteed by this feature, where DDS participants are accessible across the network, as the application uses the same DDS API for communications. \textbf{Security} features are also considered, where DDS sets a Plugin interface, that combine different plugins that interact with DDS API. These security matters will be later discussed.

            \subsubsection{Data-Centric Approach}

                Initially, systems used to prioritized the message as the establishment of the interaction, meaning that the system was mainly concerned if the message was correctly passed between nodes. This way of structuring is called Message-Centric approach, where the key is the message itself, and not its content.

                DDS architecture approach is based on a concept named \textbf{Data-Centric}, that instead of focusing on the reliable transmission of the message, the distributed infrastructure takes more responsibility, where the message-data itself is the focal point. Here, the infrastructure formally defines the data and imposes rules over it (\textbf{modular}), with the continuous awareness of the contents in the data space, where known structures exchange these contents. Therefore, the data is independent of any particular functionally of any application that uses it, because the data is described by its state, making it easily \textbf{scalable}.

                The essence of data centricity is that DDS must know the data schemas, treating the data values as known objects and controls how the data is retrieved to the applications. Thus, DDS is responsible for providing the definition of 'truth' regarding the message management.  Whereas, in the traditional message-centric approach, each application must store the message state and treated them as its own, meaning that the 'truth' of the message state is subjective. Even though this offers some flexibility to the application developers, state managing often leads to inconsistency. Rather than forcing each application to deal with this complexity of defining the data space, DDS directly implements and provides controlled, managed, secure data sharing.

            \subsubsection{DDS Architecture}

                The Data-Centric approach does not define the full DDS architecture, but only how messaging is treated as a technique. Other technologies, such as Databases supports data-centricity, but usually these are not scalable when it comes to accessing data by multiple applications, updates are slow and highly centralized, meaning that reliability of data could be potentially compromised. Since DDS uses the concept of a transport-independent virtualized \textbf{Data Bus}, scalability is not a issue, since network resources are efficiently used, and inside local networks DDS uses multicast, so that the load on the network is independent of the number of applications. There is no centralization whatsoever, maintaining the awareness on the information flow.

                Reliability is ensured by implementing a buffer mechanism, where both publisher and subscriber has a corresponding buffer where the samples of data are processed. The subscriber receives these data samples on the receive buffer, and acknowledges them back to the publisher. The sending of data is multicast, because there might be multiple subscribers to a specific topic, whereas acknowledgments and the re-sending process, that happens if a sample drops, are unicast.

                DDS is really about distributing stateful data, acessing it and querying it in motion, in a analogous way to how its done in a database or another data-centric technology, by improving these architectures and making them available for a much wider class of applications and problems.

                \begin{figure}[H]
                    \centering
                    \includegraphics[width=0.5\linewidth]{images/dds-architecture.png}
                \end{figure}

                As previously mentioned, DDS uses network resources very efficiently, meaning that hardware footprint can be reduced, or even with the same hardware, DDS offers significantly greater performance and functionality. Since DDS supports a distributed peer-to-peer topology, with no single points of failure, these capabilities are provided in a more deterministic and reliable way.

                DDS communications are also governed with explicit Quality of Service, that allows the system to manage and monitor which applications are able to communicate in which ways with the Data Bus and with each other.

                \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.5\linewidth]{images/dds-scalable-architecture.png}
                \end{figure}

                DDS provides flexibility and scalibilty to every sort of systems, from small devices, located at the "Edge" where DDS can be used for high-speed machine to machine communications, up to large systems, where DDS provides scalable access and distribution of information over the whole cloud.


            \subsubsection{Understanding DDS in ROS2}

                As stated in the previous section, ROS2 was developed with the goal of easing the former ROS architecture, by implementing an abstract middleware interface, through which serialization, transport and discovery is being provided. This means that it continues to be relatively straightforward for a developer to add and integrate a new component into an existing system. % These implementations of this interface are based on the DDS standard.

                ROS2 is built on the DDS framework, so ROS2 applications are actually considered DDS applications, which leads to flexibility and compatibility.
                Native DDS applications can freely interoperate with ROS2 DDS applications, but some restrictions have to be respected.

                \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.5\linewidth]{images/ROS2-architecture.png}
                \end{figure}

                ROS2 aims to support multiple DDS implementations, even though each of these implementations API specification differ from each other. In order to abstract from the specifics of these APIs, an abstract interface is being introduced, which can be implemented for different DDS implementations, depicted above as \textbf{Abstract DDS Layer}. This layer could be removed, if there was no need to use more than one DDS implementation. But this is not the wanted scenario, since it is way more practical to switch the DDS implementation depending on the application needs.
                This layer was already customized and implemented in ROS1, defined by the Client Library which allows the communication between the Application Layer, where the Master is implemented, and the communication protocols. The main reason behind implementing this middleware layer is so that ROS2 developers can focus on their application, instead of also focusing on all these aspects of communication configuration.

                Note that, these implementations offered by DDS are low-level of abstraction, specified by its API, with predefined functions defined by vendors. DDS only defines basic procedures in a more higher level of abstraction.


        \subsection{ROS2 Data Model}

            As previous stated, ROS provides a way of data distribution between nodes base on published and subscribed data. Before considering about how the data is passed and treated by publishing and subscribing, nodes must be studiedly covered.

            \textbf{Nodes} can be perceived as processes that will likely perform computation over the network. The network is comprised of many nodes, running simultaneously and exchanging data between them, with each node having its corresponding module purpose. Generally speaking, nodes are programs, built over a package, where their software code treats data that has been exchanged to each of them.

            In ROS2, there is a modular convention about how to program nodes, where each class inherits from the Node object, easing the life of the programmer.
            For instance, lets considered a well-known example called \texttt{TurtleSim}, which is a simulator typically used for learning ROS, mainly composed by 2 nodes, that perform together towards moving a turtle. Additional nodes were implemented so security matters could be supported. After launching each node using the predefined ROS2 run command, \texttt{ros2 run <package\_name> <node\_name>}, the running nodes can be easily checked using the command \texttt{ros2 node list}. Note that, each node has its corresponding package, and nodes can be connected within a single package or between multiple packages.

            \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.4\linewidth]{images/ts_nodelist.png}
            \end{figure}

            The communication between nodes is done by message-passing. A message is defined by its type, also known as its \textbf{interface}, which can be primitive (integer, string, boolean), or can be defined by a complex data structure, where multiple data types are assigned to their corresponding variables.

            The message that triggers the turtle movement, in the \texttt{Turtlesim} example, is composed by multiple data movement variables regarding the linear and circular movement of the turtle. The interface is called \texttt{Twist} and it is a ROS predefined geometry message.

            \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.4\linewidth]{images/ts_interface_twist.png}
            \end{figure}

            Messages are passed through via the pattern of publishing and subscribing over a \textbf{topic}. A node publishes the message to any number of topics, that are then subscribed by nodes that want to get access to that message. Topics provide a multicast routing scheme, where publish data can be casted into multiple subscribers.

            \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.7\linewidth]{images/ros2-topics.png}
            \end{figure}

            The topic is created upon specifying in the node either a publisher or a subscriber instance, providing the topic name as an argument. After building and executing the node, their associated topics are created. The available topics can be listed by running the predefined ROS command \texttt{ros2 topic list}.

            \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.3\linewidth]{images/ts_topiclist.png}
            \end{figure}

            If the nodes that want to exchange data through a topic are implemented in the same package, the respective subscriber and publisher nodes must have the same topic name instantiated. The configuration is pretty simple, whereas if the nodes are specified in different packages, a technique of \textbf{remapping} must be used.

            The topic list related to the \texttt{Turtlesim} is depicted above. The 3 listed topics are vital for the communication process, and they all correspond to the \texttt{multiplexer} node. This happens because remapping between topic names is used to establish communication between packages, as explained above.

            Both launching and remapping process are done by running a ROS \textbf{launch file}, that simultaneously launches each node, providing a simpler way of monitoring the system nodes.

            \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.5\linewidth]{images/ts_launch_file.png}
            \end{figure}

            As it can be seen, every node is instantiated in this file, and have each topic remapping defined in \texttt{remappings} section. Also, distinctive namespaces allow the system to start the nodes, without any name nor topic name conflicts.

            Running the following ROS command \texttt{ros2 launch <file\_name>}, will automatically compile and run the launch file.

            \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.7\linewidth]{images/ts_launch_ros.png}
            \end{figure}

            Every network node is now running simultaneously in the background. The only foreground running node is the turtlesim one, because it has an associated interface showing the turtle movement.

            \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.4\linewidth]{images/ts_turtle.png}
            \end{figure}

            For understanding reasons, the reader may want to see how does the network architecture is organized. ROS 2 provides a GUI tool called \textbf{rqt}, that helps the programmer in manipulating the network elements, in a more user-friendly way. This tool has a graph visualizer plugin that allows the programmer to view the network graph and how the elements are connected.

            While the nodes are running in the background, the reader may want to run the following command \texttt{rqt\_graph}, in a separated terminal. The network graph related to the \texttt{TurtleSim} is represented bellow.

            \begin{figure}[H]
                    \centering
                     \includegraphics[width=\linewidth]{images/ts_rqt_graph.png}
            \end{figure}



            \subsubsection{Other ROS concepts}

            -- services
            -- parameters
            -- actions





        \subsection{The need for Security}

            A major factor behind its popularity and widespread adoption is its flexibility and interoperability. In ROS, this flexibility was valued above all else, meaning that values like security were not considered as a priority, so ROS applications tend to face increased security risks.

            Also, ROS works over a publish-subscribe pattern, which is very useful, since it brings various forms of decoupling and transparency. However, because of this transparency, publishers within ROS are unable to control the consumption of their data and subscribers, most of the times, cannot identify the integrity of their received data. % The low barrier to entry and open nature of the ROS ecosystem %
            This means a malicious actor could potentially inject code or vulnerabilities into a library, which could then be reused by another unsuspecting developer.

            These concerns about security take on particular importance, since robots are becoming more frequently used and can directly affect the physical world. \textbf{Cyber-physical} systems, commonly related to the arising of the automatizing concept of robots, feature unique vulnerabilities that exploit both cyber and physical nature of these devices, mainly by sensing and actuating. Sensing becomes relevant when it comes to the potential leak of information about the surroundings of its robot. Whereas, actuating is related to the functionality of the robot, where physical safety is the main concern. % One of the most interesting results of the honeypot experiment is that it can be very difficult to discern between a cyber-physical  security  exploit  and  hardware  and/or  software  bugs. %

            Many researches were made regarding this issue, one in particular that explored the IPv4 address space of the Internet for instances of ROS, named \textit{Scanning the Internet for ROS: A View of Security in Robotics Research}, with the goal of identifying ROS vulnerable hosts, mostly master nodes since they provide information about their related topics and node's parameters, mainly by port scanning, so that developers could be aware of the possibility of exposure of their robots. It's mentioned that, besides their work on this subject, a lot of tools have been developed to correct the vulnerabilities that ROS formerly had. Secure Robot Operating System (SROS) was initially developed as an experimental tool (later evolved to SROS2 as a supporting tool for ROS2), which supports TLS for all socket transport, node restrictions and chains of trust, guaranteeing publishers authorization when it comes to publish to a specific topic. Another worth-mentioned tool is Rosbridge, which provides a WebSocket interface to ROS and corresponding server to allow interaction between applications and ROS nodes, by using TLS as support and also access control over topics and API calls. Other tools were also mentioned, that mainly report security concerns. The performed scans furnished information about hosts that could either be a sensor, an actuator or even a simulator. Topics were also identified since they provide evidence of what is likely to be available to an attacker. This study is rather relevant because of how easily can attackers gather information about potential robots, and control them further on, through the public Internet, making it unavoidable to develop mechanisms concerning security.

            Besides these referred solutions, it was proposed a different kind of approach when it comes to protecting the ROS network, which primarily focused on applying security measures on the application layer, treating ROS architecture as a black-box. In the paper where this solution is addressed, its proposed an architecture where features such as authentication, authorization, integrity and confidentiality is ensured, by mainly running an Authentication Server, that acts a trust-center, storing certificates and files related to trusted domain participants, while controlling and providing session keys related to the communication process. This seems promising as it prevents unauthorized nodes from accessing to data, achieved by topic-specific encryption keys assigned only to authorized application modules. Even though the message data can not be perceived, unauthorized nodes can still collect information about the flow of the data, since ROS architecture is responsible for the publish-subscribe interaction, meaning that security issues still persist which cannot be handled on the application level alone.

            ROS faces known vulnerabilities due to its architecture and model nature. ROS internal communication is built around TCP ports, allowing a world distribution of a modular robot. However, this modularity results in the exposure of TCP ports, that usually leads to cyber-attacks that compromised data.
            Also, ROS node-to-node communications are settled in plain text. Despite the fact that this way of handle communications bring certain benefits, especially better performance and data recovery, it is evident that data content is vulnerable to unauthorized usage.

            As discussed previously, this is mainly due to the fact that ROS had its own middleware, which didn't provide any security features. The 'centralization' behind ROS architecture, where everything was controlled and connected to the ROS Master node, was also a major fact to the need of a new implementation where the middleware could not also facilitate the establishment of communications, but also could provide security features. ROS2 adoption of middleware interface for data exchange offers a flexible way to build appropriate defenses for a given application.

            DDS ensures not also communication features, but also guarantees security properties, where ROS's flexibility is preserved despite this increase on security. The \textbf{DDS-Security} is a specification that serves as an add-on to the DDS specification, defined by a set of plugins combined in a Service Plugin Interface (SPI) architecture. The main plugins provided by DDS-Security are the following ones:

            \begin{itemize}
                \item[---] \textbf{Authentication}: Verification of each identity of a given Domain Participant, by assigning a private key and a public key to each one, as well as an certificate that relates the participant's public key to its corresponding specific name.
                \item[---] \textbf{Access control}: Provides control over DDS-related operations with the support of the Authentication plugin. It requires two files per domain participant signed by a Certificated Authority, that specifies how the domain should be secured and their permissions.
                \item[---] \textbf{Cryptographic}: Operations related to cryptographic purposes, such as encryption are handled by this plugin.
                \item[---] \textbf{Logging}: Provides logging over events.
                \item[---] \textbf{Data tagging}: Add tags to data samples.
            \end{itemize}

            \begin{figure}[H]
                \centering
                \includegraphics[width=0.5\linewidth]{images/dds-security.png}
            \end{figure}

            These plugins can be customized since different applications require different needs when it comes to security. That is why, as depicted above, there must be a \textbf{Standardized Plugin API} that acts as an interface between modules and DDS security protocols, while including all aspects of secure communications.
            ROS2 is deployed without security mechanisms by default, but DDS can provide security guarantees such as authentication and access control with a variant called DDS-Security. Using DDS-Security it is possible to configure ROS2 to run with security guarantees using the \textbf{SROS2} toolset. Most of these tools supported by SROS 2 is contained within the ROS Client Library (RCL), and includes the following features:

            \begin{itemize}
                \item[---] Support for security files for each domain participant, where in ROS2 are seen as a process, and each process must be associated with a set of these files.
                \item[---] Support for both permissive and strict enforcement of security, meaning that can be considered two approaches when it comes to dealing with security files.
                \item[---] Support for a master “on/off” switch, that enables or disables every security feature.
            \end{itemize}

            The SROS2 has been designed to work with any secure middleware. However, not all middleware is considered open-source and highly depends on the ROS distribution in use.

            Since this security process involves a lot of new technology, the user must be aware of improper configuration, that can still lead to security problems. However, SROS 2 CLI include a tool, named \texttt{ros2 security}, that aims to help those who don’t want to set it all up by themselves.

            \subsubsection{TurtleSim with SROS2}

            Now that the concept behind SROS2 is introduced, the \texttt{TurtleSim} application given as an example in the previous section, can now  be treated using security features related to the nodes involved.

            The \texttt{multiplexer} node handled the commands responsible for the turtle movement. Note that, the turtle is implemented in the \texttt{turtlesim} node, so both \texttt{multiplexer} and \texttt{turtlesim} nodes are directly connected through a specified topic. \texttt{Multiplexer} acts as topic selector between two different subscribed topics, where each of them was respectively associated with a priority. Based on the priority set at each moment, the \texttt{multiplexer} node forwards the command related to the selected topic into the \texttt{turtlesim} node, by topic remapping, which triggers the turtle movement. Even though the \texttt{multiplexer} handles the two specified subscribed topics that receive movement data from both \texttt{random controller} and \texttt{keyboard} nodes, its not exclusive to the \texttt{turtlesim} node, as it is still possible to directly publish commands to the topic that handles the turtle movement, since the security properties have not been implemented yet.

            In order to guarantee this exclusivity where the \texttt{multiplexer} is the only node that directly publishes data to the topic that enables the turtle movement, is by specifying \textbf{access control} files. The remaining nodes should be considered as untrustworthy, denying any potential undesired turtle movement originated by these nodes that tried to publish data through the topic. The idea is to encapsulate both \texttt{multiplexer} and \texttt{turtlesim} nodes, as the \texttt{multiplexer} monitors and manages all the data intended to manipulate the turtle movement, similar to a reversed proxy server.

            \begin{figure}[H]
                \centering
                \includegraphics[width=0.8\linewidth]{images/ts_secured_multiplexer.png}
            \end{figure}

            Note that, as it is now, the only nodes that are supervised by the \texttt{multiplexer} are the \texttt{random controller} node and the \texttt{keyboard} node. However, it can be implemented new nodes with ease, as it is only required to remap topics in the launch file and create as many subscriptions in the \texttt{multiplexer} as many implemented nodes.



%\let\clearpage\relax
\titlespacing*{\chapter}{pt}{-20pt}{20pt}
\chapter{Third Part}

    \section{Exercise 5}
    \textbf{Monads} allows us to improve our programming practices in various ways. It definitely comes associated with some drawbacks but, hopefully, the idea is still strong enough to prove itself useful in several scenarios.

	A interesting example of a monad being very useful passes through converting partial functions into total ones which allows us to express the absence of value really well. This concept exists in none functional programming languages too, like in C with pointers, for example. Just as the Maybe monad captures this functionality, other monads cover other interesting useful features. We can use the Writer monad to log information, the Powerset monad to bruteforce problems, the IO monad to interact with real-time input/output operations and many others. Therefore, they are a way to approach and easily solve specific problems (Adding functionality).

	Now, the cherry on top using monads to add functionality also passes through them being able to solve, otherwise rather difficult, tasks more naturally. The previous exercises are good examples of how the Powerset monad recurs to backtracking to obtain every possible solution to a problem. It managed to turn an algorithm that usually needs to keep a list of visited nodes into a much more trivial problem where we easily guarantee to touch every node. (Compact way to develop complex solutions).

	Another big advantage that we only saw a glimpse off during the previous exercises passes by the fact of monads having a very generic meaning. It's basically guaranteed that one can just replace the outer monad of a certain function and arrive to something with a valuable meaning in a different concept. % (Generic meaning/Reusing stuff --- Add example).

	However, as we mentioned right on opening, they do have drawbacks. The first and, probably, the one that justifies the most the lack of effort to actually interact with this interfaces passes through the steep learning curve. Coming from category theory, monads definitely require some background understanding to actually see how the concept manages to apply so well to different problems. (Steep learning curve)

	Another, more important, drawback comes from the fact that monads don't scale particularly well. It's all fine when we are using maybe 2 or 3 monads on a stack because the boilerplate code is still tolerable. With very big stacks, despite having access to various composed functionalities that can cover entirely anything that a piece of software might need (state, reading data, logging data, etc), comes a lot of boilerplate code due to constantly needing to relocate the context to the operation that one needs to do. We do lack some experience when it comes to working with real-world examples of monad stacks so we might actually be missing our point here, and perhaps it's actually not as bad as we've noticed so far.

	Either way, monads are definitely worth learning especially due to the way that they influence our way of thinking about a problem. Modelling before solving is the way to actually develop software and monads are one of the best proofs of that fact.


%\let\clearpage\relax
\titlespacing*{\chapter}{pt}{-20pt}{20pt}
\chapter{Fourth Part}

    \section{Exercise 6}
    As requested in this exercise, we tried our best to create significant functionalities whilst recurring to monadic machinery. In order to try to explain our motivation for each chosen monad, in the following subsections we describe every functionality that we added and how it was naturally (and easily) represented with a certain monad.

    \subsection{IO monad - Generic graphs}
    Our first intention was to generalize the base graph, allowing the user to adjust the graph to his own needs. As mentioned by the teacher, this was done by using the IO monad. At first, this required us to have a lot more arguments in our functions (a list of adjacencies and nodes) but later they were simply included in our state.

    \subsection{State monad - Eletric bus and the free, complete, rides!}
    Despite the teacher mentioning that we should try to avoid using functionalities that other groups might use, we've always been particularly curious about the State monad. It looks a lot harder than what it actually is. It was used, as suggested, to create a notion of battery and understand if there were paths that could be done by an electric bus without ever losing it's battery entirely.

    \subsection{The necessity of a list monad transformer}
    While we were implementing the above functionality we incurred in a problem. The State was covering every path which didn't allowed us to represent the battery "individually". To solve that problem, we started using a list monad transformer that gave us the ability to produce a state for each path.

    \subsection{Exception monad - Traffic info and other potential mishap's}
    Another interesting functionality that we felt would fit well in the problem was the possibility of, by some specific reason, not being able to complete the path. This could occur because there was a sinkhole on a street or maybe the bus had a flat tire! To implement this, we used the Exception monad.

    We created 2 types of errors, one representing local failures that might happen to a specific bus and another type to represent failures that are known by external sources, for example, a road block on an edge.

    \subsection{Writer Monad - Knowing what path was being followed until a failure}
    The previous functionality, despite being relevant, brought some redundancy to our final output. It could happen that multiple paths failed for the same reason, which would be displayed simply as the same error 3 times. This motivated us to use the Writer monad to be aware of what path was being followed until the failure happened!

    \subsection{Summing up}
    We know we might have gone a bit overboard by using so many functionalities, but our main motivation to doing this was to "test" our written essay about why monads matter. Every time we added a new monad to our stack, the changes were very, very minimal. We also managed to isolate each monad functionality in a very visible way and managed to have somewhat generic functions all around our program.
    None of us had a lot of experience with monad transformers until this point, but this project definitely showed us that they are very interesting and powerful.


\newpage
\titlespacing*{\chapter}{pt}{-20pt}{20pt}
\chapter{Conclusion}
    In conclusion, this was a great project to finish our last “typical” semester. We have always been told that formal methods associates with a lot of advantages but, in many occasions, we don’t get to see their use in complex, real world scenarios.

    With this project, however, we got a taste of what seems to be real world Haskell and worked with very advanced concepts that are core to develop software recurring to functional programming.

    On pair with the above, we also grasped this concepts in a more theoretical manner due to the lambda calculus exercises which gave us a different perspective of these matters.

    Our main difficulties differed between the Haskell and the lambda calculus parts. Regarding the Haskell exercises, we only encountered difficulties in the last exercise, especially when it came to understanding exactly what real world concept could be represented by a certain monad. Code-wise it went fairly well since we already had some background in the language.

    Regarding lambda calculus, our main difficulties were finding which was the right applying rule, so that the logical process of deducting was preserved and consequently each $\lambda$-term had the proper interpreted function.

    It was an interesting project that shed a light on many important concepts and we think that other previous projects should try to force us to deal with more real examples and concepts.

\newpage
\end{document}\documentclass[11pt,a4paper]{report}%especifica o tipo de documento que tenciona escrever: carta, artigo, relatório... neste caso é um relatório
% [11pt,a4paper] Define o tamanho principal das letras do documento. caso não especifique uma delas, é assumido 10pt
% a4paper -- Define o tamanho do papel.

\usepackage[english]{babel}%Babel -- irá activar automaticamente as regras apropriadas de hifenização para a língua todo o
                                   %-- o texto gerado é automaticamente traduzido para Português.
                                   %  Por exemplo, “chapter” irá passar a “capítulo”, “table of contents” a “conteúdo”.
                                   % portuges -- específica para o Português.
\usepackage[utf8]{inputenc} % define o encoding usado texto fonte (input)--usual "utf8" ou "latin1

\usepackage{graphicx} %permite incluir graficos, tabelas, figuras
\usepackage{url} % para utilizar o comando \url{}
\usepackage{enumerate} %permite escolher, nas listas enumeradas, se os iems sao marcados com letras ou numeros-romanos em vez de numeracao normal

\usepackage{hyperref}

%\usepackage{apalike} % gerar biliografia no estilo 'named' (apalike)

\usepackage{color} % Para escrever em cores

\usepackage{multirow} %tabelas com multilinhas
\usepackage{array} %formatação especial de tabelas em array

\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage{titlesec, blindtext, color}
\definecolor{gray75}{gray}{0.75}
\newcommand{\hsp}{\hspace{20pt}}
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}
\usepackage{tabularx}


\usepackage{minted}
\usepackage{tcolorbox}

%Exemplos de fontes -- nao e vulgar mudar o tipo de fonte
%\usepackage{tgbonum} % Fonte de letra: TEX Gyre Bonum
%\usepackage{lmodern} % Fonte de letra: Latin Modern Sans Serif
%\usepackage{helvet}  % Fonte de letra: Helvetica
%\usepackage{charter} % Fonte de letra:Charter

\definecolor{saddlebrown}{rgb}{0.55, 0.27, 0.07} % para definir uma nova cor, neste caso 'saddlebrown'
\newcommand\tab[1][1cm]{\hspace*{#1}}

\usepackage{listings}  % para utilizar blocos de texto verbatim no estilo 'listings'
%paramerização mais vulgar dos blocos LISTING - GENERAL
\lstset{
	basicstyle=\small, %o tamanho das fontes que são usadas para o código
	numbers=left, % onde colocar a numeração da linha
	numberstyle=\tiny, %o tamanho das fontes que são usadas para a numeração da linha
	numbersep=5pt, %distancia entre a numeração da linha e o codigo
	breaklines=true, %define quebra automática de linha
    frame=tB,  % caixa a volta do codigo
	mathescape=true, %habilita o modo matemático
	escapeinside={(*@}{@*)}, % se escrever isto  aceita tudo o que esta dentro das marcas e nao altera
	gobble=8, tabsize=4
}
%
%\lstset{ %
%	language=Java,							% choose the language of the code
%	basicstyle=\ttfamily\footnotesize,		% the size of the fonts that are used for the code
%	keywordstyle=\bfseries,					% set the keyword style
%	%numbers=left,							% where to put the line-numbers
%	numberstyle=\scriptsize,				% the size of the fonts that are used for the line-numbers
%	stepnumber=2,							% the step between two line-numbers. If it's 1 each line
%											% will be numbered
%	numbersep=5pt,							% how far the line-numbers are from the code
%	backgroundcolor=\color{white},			% choose the background color. You must add \usepackage{color}
%	showspaces=false,						% show spaces adding particular underscores
%	showstringspaces=false,					% underline spaces within strings
%	showtabs=false,							% show tabs within strings adding particular underscores
%	frame=none,								% adds a frame around the code
%	%abovecaptionskip=-.8em,
%	%belowcaptionskip=.7em,
%	tabsize=2,								% sets default tabsize to 2 spaces
%	captionpos=b,							% sets the caption-position to bottom
%	breaklines=true,						% sets automatic line breaking
%	breakatwhitespace=false,				% sets if automatic breaks should only happen at whitespace
%	title=\lstname,							% show the filename of files included with \lstinputlisting;
%											% also try caption instead of title
%	escapeinside={\%*}{*)},					% if you want to add a comment within your code
%	morekeywords={*,...}					% if you want to add more keywords to the set
%}

\usepackage{xspace} % deteta se a seguir a palavra tem uma palavra ou um sinal de pontuaçao se tiver uma palavra da espaço, se for um sinal de pontuaçao nao da espaço

\parindent=0pt %espaço a deixar para fazer a  indentação da primeira linha após um parágrafo
\parskip=2pt % espaço entre o parágrafo e o texto anterior

\setlength{\oddsidemargin}{-1cm} %espaço entre o texto e a margem
\setlength{\textwidth}{18cm} %Comprimento do texto na pagina
\setlength{\headsep}{-1cm} %espaço entre o texto e o cabeçalho
\setlength{\textheight}{23cm} %altura do texto na pagina

%\input{LPgeneralDefintions} %permite ler de um ficheiro de texto externo mais definições
%\lhead{lado esquerdo do cabeçalho}
%\chead{parte central do cabeçalho}
%\rhead{lado direito do cabeçalho}
%\lfoot{lado esquerdo do rodapé}
%\cfoot{parte central do rodapé}
%\rfoot{lado direito do rodapé}

\begin{document} % corpo do documento
%\maketitle % apresentar titulo, autor e data


\begin{titlepage}
    \centering
    {\Large
        \huge Thesis Dissertation\\
    }

    \Large Formalizing ROS2 security configuration with Alloy

    \vfill
    \begin{center}\large

        \begin{tabular}{ll}
            \textbf{a85954} & \textbf{Luís Ribeiro}
        \end{tabular}

    \end{center}
    \includegraphics[width=8cm]{images/UM.jpg} % also works with logo.pdf
    \begin{center}
        \large Mestrado em Engenharia Informática\\
            Universidade do Minho

    \end{center}

    \vfill
    \vfill
    \vfill
\end{titlepage}

\newpage
\tableofcontents{}
\newpage

%\let\clearpage\relax
%\titlespacing*{\chapter}{pt}{-20pt}{20pt}
%\chapter{Introduction}

%This assignment revolves around the Travelling Salesman Problem (TSP). This problem is one of those that can be easily formulated but whose answer cannot be efficiently obtained. For that reason, our task in this assignment aims to model and analyse different variants of TSP via \textbf{monads} and their facilities.\\
%Every exercise has its own section, so that


\titlespacing*{\chapter}{pt}{-20pt}{20pt}
\chapter{Concepts Introduction}

    \section{Robotic Operating System}

        This dissertation focus on the exploration of potential non-studied properties related to the security of the robotic world. Therefore, before taking consideration about security matters, \textbf{R}obotic \textbf{O}perating \textbf{S}ystem, known simply as \textbf{ROS}, must be introduced. At first it may seem that its being dealt with an Operating System, but its actually a open-source framework, composed by software libraries and tools with the aim of helping build robot applications easily, without the need of building it from scratch. ROS was designed to be flexible, since working with robots requires experimentation, given the variety of different hardware and software. This flexibility enables the combination between existing components with new ones.

        \subsection{Evolving into ROS2}

            ROS provides a distributed architecture that operates as a publish-subscribe service to distribute data among nodes in a system. The first version of ROS, namely ROS1, uses a custom serialization format, a custom transport protocol as well as a custom central discovery mechanism, meaning that the interface layer, called the communication middleware, was implemented by them.

            The main ideia behind having implemented their own middleware is that there was a need to have a \textbf{Master node}, that controlled every aspect of the communication establishment, acting as DNS server to the nodes that want to exchange information. Before running any node, a ROS Master node must be initialized, in order to retrieve information to the node that is running. Also, the location of the ROS Master must be addressable by the network nodes. The parameters, which in ROS provides useful runtime information about nodes, was also handled by the ROS Master. This \textbf{centralization} fits the purposes of a research tool, because of the vast capabilities that is controlled by the master, but does not scale well, making it unsuitable for safety-critical and real-time systems. It is considered a performance bottleneck because everything has to go through the master. If the master goes down then the whole system goes down, representing a single-point of failure.

            \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.5\linewidth]{images/former-ros1-architecture.png}
            \end{figure}

            This lead to the creation of \textbf{ROS2}, which continues to provide a simple, uniform message passing interface to allow components to communicate with each other, now implemented using the Data Distribution Service (DDS) communication protocol as middleware. This means that there is no need to implement a master, making the system fully distributed. The discovery process between nodes is distributed and guaranteed by DDS, giving theses nodes the capacity to discover other nodes. Considering that there is no ROS Master implemented, the approach when dealing with the parameters also changed. Instead of having a global parameter server, in ROS2 each node declares and manages its own parameters. All these aspects related to ROS2 will be later discussed.



        \subsection{Data Distribution Service: A Data-Centric Approach}

            \textbf{Data Distributed System}, known as DDS, is a middleware Object Management Group (OMG) standard, directly addressing data communication between nodes that belong to a \textit{publish-subscribe} communication architecture, for real-time and embedded systems, that relies on a data-centric approach.

            A middleware, such as DDS, is the software layer that comes between the \textbf{Platform layer}, where configuration about operating systems and network transport is covered, and the \textbf{Application layer}. By that, developers can mainly focus on their applications purposes, instead of concerning about information passing between layers.

            \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.5\linewidth]{images/middleware.png}
            \end{figure}

            Usually, middlewares are implemented by distributed systems, that rely on timing-measures and efficiency when it comes to data-delivering between nodes. DDS aims to ease the complexity of building their own middleware. Complex network configuration, communication establishment, data sharing and low-level details are handled by DDS. The specification of \textbf{Quality of Service} (QoS) parameters is a great feature, because of the versatility that each one offers to the system. Re-sending messages that did not reach their destination, multicast updates, dynamic resizing of messages, version tracking and many other parameters can be useful to satisfy some system requirements.
            When it comes to easing the communication establishment, DDS features a \textbf{Dynamic Discovery} within nodes, by providing automatic discovery between endpoints and useful information about them. Network configuration is also guaranteed by this feature, where DDS participants are accessible across the network, as the application uses the same DDS API for communications. \textbf{Security} features are also considered, where DDS sets a Plugin interface, that combine different plugins that interact with DDS API. These security matters will be later discussed.

            \subsubsection{Data-Centric Approach}

                Initially, systems used to prioritized the message as the establishment of the interaction, meaning that the system was mainly concerned if the message was correctly passed between nodes. This way of structuring is called Message-Centric approach, where the key is the message itself, and not its content.

                DDS architecture approach is based on a concept named \textbf{Data-Centric}, that instead of focusing on the reliable transmission of the message, the distributed infrastructure takes more responsibility, where the message-data itself is the focal point. Here, the infrastructure formally defines the data and imposes rules over it (\textbf{modular}), with the continuous awareness of the contents in the data space, where known structures exchange these contents. Therefore, the data is independent of any particular functionally of any application that uses it, because the data is described by its state, making it easily \textbf{scalable}.

                The essence of data centricity is that DDS must know the data schemas, treating the data values as known objects and controls how the data is retrieved to the applications. Thus, DDS is responsible for providing the definition of 'truth' regarding the message management.  Whereas, in the traditional message-centric approach, each application must store the message state and treated them as its own, meaning that the 'truth' of the message state is subjective. Even though this offers some flexibility to the application developers, state managing often leads to inconsistency. Rather than forcing each application to deal with this complexity of defining the data space, DDS directly implements and provides controlled, managed, secure data sharing.

            \subsubsection{DDS Architecture}

                The Data-Centric approach does not define the full DDS architecture, but only how messaging is treated as a technique. Other technologies, such as Databases supports data-centricity, but usually these are not scalable when it comes to accessing data by multiple applications, updates are slow and highly centralized, meaning that reliability of data could be potentially compromised. Since DDS uses the concept of a transport-independent virtualized \textbf{Data Bus}, scalability is not a issue, since network resources are efficiently used, and inside local networks DDS uses multicast, so that the load on the network is independent of the number of applications. There is no centralization whatsoever, maintaining the awareness on the information flow.

                Reliability is ensured by implementing a buffer mechanism, where both publisher and subscriber has a corresponding buffer where the samples of data are processed. The subscriber receives these data samples on the receive buffer, and acknowledges them back to the publisher. The sending of data is multicast, because there might be multiple subscribers to a specific topic, whereas acknowledgments and the re-sending process, that happens if a sample drops, are unicast.

                DDS is really about distributing stateful data, acessing it and querying it in motion, in a analogous way to how its done in a database or another data-centric technology, by improving these architectures and making them available for a much wider class of applications and problems.

                \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.5\linewidth]{images/dds-architecture.png}
                \end{figure}

                As previously mentioned, DDS uses network resources very efficiently, meaning that hardware footprint can be reduced, or even with the same hardware, DDS offers significantly greater performance and functionality. Since DDS supports a distributed peer-to-peer topology, with no single points of failure, these capabilities are provided in a more deterministic and reliable way.

                DDS communications are also governed with explicit Quality of Service, that allows the system to manage and monitor which applications are able to communicate in which ways with the Data Bus and with each other.

                \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.5\linewidth]{images/dds-scalable-architecture.png}
                \end{figure}

                DDS provides flexibility and scalibilty to every sort of systems, from small devices, located at the "Edge" where DDS can be used for high-speed machine to machine communications, up to large systems, where DDS provides scalable access and distribution of information over the whole cloud.


            \subsubsection{Understanding DDS in ROS2}

                As stated in the previous section, ROS2 was developed with the goal of easing the former ROS architecture, by implementing an abstract middleware interface, through which serialization, transport and discovery is being provided. This means that it continues to be relatively straightforward for a developer to add and integrate a new component into an existing system. % These implementations of this interface are based on the DDS standard.

                ROS2 is built on the DDS framework, so ROS2 applications are actually considered DDS applications, which leads to flexibility and compatibility.
                Native DDS applications can freely interoperate with ROS2 DDS applications, but some restrictions have to be respected.

                \begin{figure}[H]
                    \centering
                     \includegraphics[width=0.5\linewidth]{images/ROS2-architecture.png}
                \end{figure}

                ROS2 aims to support multiple DDS implementations, even though each of these implementations API specification differ from each other. In order to abstract from the specifics of these APIs, an abstract interface is being introduced, which can be implemented for different DDS implementations, depicted above as \textbf{Abstract DDS Layer}. This layer could be removed, if there was no need to use more than one DDS implementation. But this is not the wanted scenario, since it is way more practical to switch the DDS implementation depending on the application needs.
                This layer was already customized and implemented in ROS1, defined by the Client Library which allows the communication between the Application Layer, where the Master is implemented, and the communication protocols. The main reason behind implementing this middleware layer is so that ROS2 developers can focus on their application, instead of also focusing on all these aspects of communication configuration.

                Note that, these implementations offered by DDS are low-level of abstraction, specified by its API, with predefined functions defined by vendors. DDS only defines basic procedures in a more higher level of abstraction.



        \subsection{ROS2 Data Model}

            % In ROS2, there is a convention about how to write your nodes. You have to create a class which inherits from the Node object. This is great because it will save everyone a lot of time. You already have a good, modular structure for writing your node -> cleaner programs.


        \subsection{The need for Security}

            A major factor behind its popularity and widespread adoption is its flexibility and interoperability. In ROS, this flexibility was valued above all else, meaning that values like security were not considered as a priority, so ROS applications tend to face increased security risks. The low barrier to entry and open nature of the ROS ecosystem means a malicious actor could potentially inject code or vulnerabilities into a library, which could then be reused by another unsuspecting developer.

            These concerns about security take on particular importance, since robots are becoming more frequently used and can directly affect the physical world, by sensing or even actuating. Sensing becomes relevant when it comes to the potential leak of information about the surroundings of its robot. Whereas, actuating is related to the functionality of the robot, where physical safety is the main concern.

            Many researches were made regarding this issue, one in particular that explored the IPv4 address space of the Internet for instances of ROS, named \textit{Scanning the Internet for ROS: A View of Security in Robotics Research}, with the goal of identifying ROS vulnerable hosts, mostly master nodes since they provide information about their related topics and node's parameters, mainly by port scanning, so that developers could be aware of the possibility of exposure of their robots. It's mentioned that, besides their work on this subject, a lot of tools have been developed to correct the vulnerabilities that ROS formerly had. Secure Robot Operating System (SROS) was initially developed as an experimental tool (later evolved to SROS2 as a supporting tool for ROS2), which supports TLS for all socket transport, node restrictions and chains of trust, guaranteeing publishers authorization when it comes to publish to a specific topic. Another worth-mentioned tool is Rosbridge, which provides a WebSocket interface to ROS and corresponding server to allow interaction between applications and ROS nodes, by using TLS as support and also access control over topics and API calls. Other tools were also mentioned, that mainly report security concerns. The performed scans furnished information about hosts that could either be a sensor, an actuator or even a simulator. Topics were also identified since they provide evidence of what is likely to be available to an attacker. This study is rather relevant because of how easily can attackers gather information about potential robots, and control them further on, through the public Internet, making it unavoidable to develop mechanisms concerning security.

            As discussed previously, this is mainly due to the fact that ROS had its own middleware, which didn't provide any security features. The 'centralization' behind ROS architecture, where everything was controlled and connected to the ROS Master node, was also a major fact to the need of a new implementation where the middleware could not also facilitate the establishment of communications, but also could provide security features. ROS2 adoption of middleware interface for data exchange offers a flexible way to build appropriate defenses for a given application.

            DDS ensures not also communication features, but also guarantees security properties, where ROS's flexibility is preserved despite this increase on security. The \textbf{DDS-Security} is a specification that serves as an add-on to the DDS specification, defined by a set of plugins combined in a Service Plugin Interface (SPI) architecture. The main plugins provided by DDS-Security are the following ones:

            \begin{itemize}
                \item[---] \textbf{Authentication}: Verification of each identity of a given Domain Participant, by assigning a private key and a public key to each one, as well as an certificate that relates the participant's public key to its corresponding specific name.
                \item[---] \textbf{Access control}: Provides control over DDS-related operations with the support of the Authentication plugin. It requires two files per domain participant signed by a Certificated Authority, that specifies how the domain should be secured and their permissions.
                \item[---] \textbf{Cryptographic}: Operations related to cryptographic purposes, such as encryption are handled by this plugin.
                \item[---] \textbf{Logging}: Provides logging over events.
                \item[---] \textbf{Data tagging}: Add tags to data samples.
            \end{itemize}

            \begin{figure}[H]
                \centering
                \includegraphics[width=0.5\linewidth]{images/dds-security.png}
            \end{figure}

            These plugins can be customized since different applications require different needs when it comes to security. That is why, as depicted above, there must be a \textbf{Standardized Plugin API} that acts as an interface between modules and DDS security protocols, while including all aspects of secure communications.

            ROS2 is deployed without security mechanisms by default, but DDS can provide security guarantees such as authentication and access control with a variant called DDS-Security. Using DDS-Security it is possible to configure ROS2 to run with security guarantees using the \textbf{SROS2} toolset. Most of these tools supported by SROS 2 is contained within the ROS Client Library (RCL), and includes the following features:

            \begin{itemize}
                \item[---] Support for security files for each domain participant, where in ROS2 are seen as a process, and each process must be associated with a set of these files.
                \item[---] Support for both permissive and strict enforcement of security, meaning that can be considered two approaches when it comes to dealing with security files.
                \item[---] Support for a master “on/off” switch, that enables or disables every security feature.
            \end{itemize}

            Since this security process involves a lot of new technology, the user must be aware of improper configuration, that can still lead to security problems. However, SROS 2 CLI include a tool, named \texttt{ros2 security}, that aims to help those who don’t want to set it all up by themselves.




%\let\clearpage\relax
\titlespacing*{\chapter}{pt}{-20pt}{20pt}
\chapter{Third Part}

    \section{Exercise 5}
    \textbf{Monads} allows us to improve our programming practices in various ways. It definitely comes associated with some drawbacks but, hopefully, the idea is still strong enough to prove itself useful in several scenarios.

	A interesting example of a monad being very useful passes through converting partial functions into total ones which allows us to express the absence of value really well. This concept exists in none functional programming languages too, like in C with pointers, for example. Just as the Maybe monad captures this functionality, other monads cover other interesting useful features. We can use the Writer monad to log information, the Powerset monad to bruteforce problems, the IO monad to interact with real-time input/output operations and many others. Therefore, they are a way to approach and easily solve specific problems (Adding functionality).

	Now, the cherry on top using monads to add functionality also passes through them being able to solve, otherwise rather difficult, tasks more naturally. The previous exercises are good examples of how the Powerset monad recurs to backtracking to obtain every possible solution to a problem. It managed to turn an algorithm that usually needs to keep a list of visited nodes into a much more trivial problem where we easily guarantee to touch every node. (Compact way to develop complex solutions).

	Another big advantage that we only saw a glimpse off during the previous exercises passes by the fact of monads having a very generic meaning. It's basically guaranteed that one can just replace the outer monad of a certain function and arrive to something with a valuable meaning in a different concept. % (Generic meaning/Reusing stuff --- Add example).

	However, as we mentioned right on opening, they do have drawbacks. The first and, probably, the one that justifies the most the lack of effort to actually interact with this interfaces passes through the steep learning curve. Coming from category theory, monads definitely require some background understanding to actually see how the concept manages to apply so well to different problems. (Steep learning curve)

	Another, more important, drawback comes from the fact that monads don't scale particularly well. It's all fine when we are using maybe 2 or 3 monads on a stack because the boilerplate code is still tolerable. With very big stacks, despite having access to various composed functionalities that can cover entirely anything that a piece of software might need (state, reading data, logging data, etc), comes a lot of boilerplate code due to constantly needing to relocate the context to the operation that one needs to do. We do lack some experience when it comes to working with real-world examples of monad stacks so we might actually be missing our point here, and perhaps it's actually not as bad as we've noticed so far.

	Either way, monads are definitely worth learning especially due to the way that they influence our way of thinking about a problem. Modelling before solving is the way to actually develop software and monads are one of the best proofs of that fact.


%\let\clearpage\relax
\titlespacing*{\chapter}{pt}{-20pt}{20pt}
\chapter{Fourth Part}

    \section{Exercise 6}
    As requested in this exercise, we tried our best to create significant functionalities whilst recurring to monadic machinery. In order to try to explain our motivation for each chosen monad, in the following subsections we describe every functionality that we added and how it was naturally (and easily) represented with a certain monad.

    \subsection{IO monad - Generic graphs}
    Our first intention was to generalize the base graph, allowing the user to adjust the graph to his own needs. As mentioned by the teacher, this was done by using the IO monad. At first, this required us to have a lot more arguments in our functions (a list of adjacencies and nodes) but later they were simply included in our state.

    \subsection{State monad - Eletric bus and the free, complete, rides!}
    Despite the teacher mentioning that we should try to avoid using functionalities that other groups might use, we've always been particularly curious about the State monad. It looks a lot harder than what it actually is. It was used, as suggested, to create a notion of battery and understand if there were paths that could be done by an electric bus without ever losing it's battery entirely.

    \subsection{The necessity of a list monad transformer}
    While we were implementing the above functionality we incurred in a problem. The State was covering every path which didn't allowed us to represent the battery "individually". To solve that problem, we started using a list monad transformer that gave us the ability to produce a state for each path.

    \subsection{Exception monad - Traffic info and other potential mishap's}
    Another interesting functionality that we felt would fit well in the problem was the possibility of, by some specific reason, not being able to complete the path. This could occur because there was a sinkhole on a street or maybe the bus had a flat tire! To implement this, we used the Exception monad.

    We created 2 types of errors, one representing local failures that might happen to a specific bus and another type to represent failures that are known by external sources, for example, a road block on an edge.

    \subsection{Writer Monad - Knowing what path was being followed until a failure}
    The previous functionality, despite being relevant, brought some redundancy to our final output. It could happen that multiple paths failed for the same reason, which would be displayed simply as the same error 3 times. This motivated us to use the Writer monad to be aware of what path was being followed until the failure happened!

    \subsection{Summing up}
    We know we might have gone a bit overboard by using so many functionalities, but our main motivation to doing this was to "test" our written essay about why monads matter. Every time we added a new monad to our stack, the changes were very, very minimal. We also managed to isolate each monad functionality in a very visible way and managed to have somewhat generic functions all around our program.
    None of us had a lot of experience with monad transformers until this point, but this project definitely showed us that they are very interesting and powerful.


\newpage
\titlespacing*{\chapter}{pt}{-20pt}{20pt}
\chapter{Conclusion}
    In conclusion, this was a great project to finish our last “typical” semester. We have always been told that formal methods associates with a lot of advantages but, in many occasions, we don’t get to see their use in complex, real world scenarios.

    With this project, however, we got a taste of what seems to be real world Haskell and worked with very advanced concepts that are core to develop software recurring to functional programming.

    On pair with the above, we also grasped this concepts in a more theoretical manner due to the lambda calculus exercises which gave us a different perspective of these matters.

    Our main difficulties differed between the Haskell and the lambda calculus parts. Regarding the Haskell exercises, we only encountered difficulties in the last exercise, especially when it came to understanding exactly what real world concept could be represented by a certain monad. Code-wise it went fairly well since we already had some background in the language.

    Regarding lambda calculus, our main difficulties were finding which was the right applying rule, so that the logical process of deducting was preserved and consequently each $\lambda$-term had the proper interpreted function.

    It was an interesting project that shed a light on many important concepts and we think that other previous projects should try to force us to deal with more real examples and concepts.

\newpage
\end{document}

