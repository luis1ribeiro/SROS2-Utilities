\chapter{Alloy Specification Framework}\label{c:alloy}

As aforementioned, this thesis aims to tackle the security vulnerabilities resulted from the miss-configuration over ROS files. In this chapter, it is intended to explore the Alloy framework that is relevant to overcome the above-mentioned challenge. % as well as previous developed work that has the same or similar goals as this thesis (\ref{s:alloy-relWork}).

As result of the increased usage of robotics, and with their integration into the human world, security ensurance for robotics software is highly required. The use of formal methods, especially in systems highly reliant on flexibility and reliability, is recommended to avoid security-critical faults. \cite{carvalho2020analysis} Software frameworks designed for this purpose must provide methods to perform structural design over systems with rich structures, abstracting their behaviour as a conventional model. Additionally, these frameworks must support features to enable automate analysis, in which property evaluation over these designed models is used as technique. 

The \textit{Alloy Framework} \cite{alloy-DJ}, fits within within this context, as it furnishes a declarative specification language, based on the relation concept, used for software modelling, with extended tools supporting analysis over these models. \cite{alloy-6} The language combination of both relational and linear temporal logic (LTL) enables the ability to model both systems with rich structures and complex behaviour. To address the correctness over the specified model, Alloy performs model-checking techniques over these logic languages, where the latter is exhaustively checked over property verification. \cite{lwspecification, carvalho2020analysis}

The framework includes an IDE, as well as an \textit{analyzer} that takes the specified model's restrictions into account, and performs bounded and unbounded model checking to find instances that satisfy those implied restrictions. It can be also be useful for checking model properties, where the analyzer will try to return a counterexample instance. Instances are displayed by the framework Visualizer, alongside with the modelling process steps, regarding a trace representation. Instances appearance can be customized, using the \textit{theme}'s extension. \cite{alloy-6}

This chapter will go through these principles in further depth, to give the reader a proper review on how Alloy is structured, as its importance as a model checker to the computation domain, supported by a previously configured example where ROS communication architecture is structurally modelled.

\section{Structural Design}

The \textit{Alloy framework} presents itself as a formal modelling language, conceived to properly address model-checking techniques over their specification language, where both structural design and temporal behaviour, naturally specified over properties, can easily be defined. Formerly, Alloy was inherently static \cite{lwspecification}, meaning that it only excel the structural design, where its language was based on first-order logic. The analysis process relied on a bounded model checking technique with no support for temporal behaviour. Notwithstanding, the latest realease of Alloy confers the ability to properly deal with expressive temporal properties, as well as trace evaluation over time, while employing the former structural approach. 

As intentionally design to formally abstract both system's configuration and behaviour, Alloy successfully incorporates a set of features, within a well-documented and wide-ranged syntax that consequently allows large specification development. \cite{carvalho2020analysis} The following subsection \ref{c:alloy-sm} addresses the Alloy concepts required for understanding how system modelling is covered. 

% Before accurately accounting both structural design as modelling technique and structural analysis, it follows the Alloy formal syntax.
%  
% \begin{lstlisting}[title={Alloy's syntax.}]
% alloyModule ::= [moduleDecl] import* paragraph*
% moduleDecl ::= module qualName [[name,+]]
% import ::= open qualName [[qualName,+]] [as name]
% paragraph ::= sigDecl | factDecl | predDecl | funDecl
%     | assertDecl | cmdDecl
% sigDecl ::= [var] [abstract] [mult] sig name,+ [sigExt] { fieldDecl,* } [block]
% sigExt ::= extends qualName | in qualName [+ qualName]*
% mult ::= lone | some | one
% fieldDecl ::= [var] decl
% decl ::= [disj] name,+ : [disj] expr
% factDecl ::= fact [name] block
% predDecl ::= pred [qualName .] name [paraDecls] block
% funDecl ::= fun [qualName .] name [paraDecls] : expr { expr }
% paraDecls ::= ( decl,* ) | [ decl,* ]
% assertDecl ::= assert [name] block
% cmdDecl ::= [name :] ( run | check ) ( qualName | block ) [scope]
% scope ::= for number [but typescope,+] | for typescope,+
% typescope ::= [exactly] number qualName
% expr ::= const | qualName | @name | this
%     | unOp expr | expr binOp expr | expr arrowOp expr
%     | expr [ expr,* ]
%     | expr [! | not] compareOp expr
%     | expr ( => | implies ) expr else expr
%     | let letDecl,+ blockOrBar
%     | quant decl,+ blockOrBar
%     | { decl,+ blockOrBar }
%     | expr '
%     | ( expr ) | block
% const ::= [-] number | none | univ | iden
% unOp ::= ! | not | no | mult | set | # | ~ | * | ^ 
%     | always | eventually | after | before | historically | once
% binOp ::= || | or | && | and | <=> | iff | => | implies | 
%     & | + | - | ++ | <: | :> | . | until | releases | since | triggered | ;
% arrowOp ::= [mult | set] -> [mult | set]
% compareOp ::= in | = | < | > | =< | =>
% letDecl ::= name = expr
% block ::= { expr* }
% blockOrBar ::= block | bar expr
% bar ::= |
% quant ::= all | no | sum | mult
% qualName ::= [this/] ( name / )* name
% \end{lstlisting}

\subsection{System Modelling}\label{c:alloy-sm}

Alloy aims to address the complexity behind richly structured systems, that require critical control over their intended behaviour, by presenting a novel approach for abstracting these systems as conventional models. System's structures can be specified over time-evolving states, where its behaviour clearly identifies the states' inbetween transitions. Thus, the conception of system transitioning offers a great formal approach when it comes to reason about the system's design.

The Alloy structural definition relies on a relation way of connecting system's elements, where the latter is abstracted in terms of relations. In Alloy, unary relations, commonly known as sets, are labelled as \textit{signatures}, that are inhabited by a set of \textit{atoms}, from a finite universe of discourse. Atoms are perceived as the lowest-grain elements, with no particular semantics attached. A signature, identified by the keyword \textit{sig}, might include multiple \textit{field} declarations enclosed between braces, addressing relation between the signature's atoms and a set or other relation. Fields are inhabited by tuples of atoms from the universe, that must meet the same arity.

Signatures can either be perceived as a top-level signature, or as other signature's subset. Signature hierarchy is conceivable through disjoint extensions (\textit{extends}), or by set inclusion (\textit{in}). The \textit{abstract} keyword declares a signature that contains no atoms beyond those within its extensions. 

To address default configuration over the universe's multiplicity, both signatures and fields can be specified under a multiplicity constraint. The former constrains the number of signature atoms, where it is commonly used to express singleton sets, over the constraint keyword \textit{one sig}. Fields, however, makes great use of multiplicities, offering behaviour expressness over relations between atoms. Additionally to these model constraints, implicitly specified over the course of the modelling process, system assumptions can be defined over axioms, expressed as \textit{facts}, where multiple constraints can be incorporated.

Moreover, the newest Alloy version enables evaluation changing throughout the trace evolution, consequently allowing the consideration of both signatures and fields as time mutable declarations, through the usage of the keyword \textit{var}.

Throughout the sections that follow, it will be presented an illustrive example over which graph theory rests, this being the study of \textit{Eulerian Circuits}. This example will be used to duly contextualize both modelling and verification process in Alloy. \textit{Eulerian Circuits} must meet several behaviour constraints over the classic graph definition, that must be addressed over axioms. However, the structural modelling must be provided beforehand.

\subsubsection{Common Structure}

The \textit{Eulerian} path denotes a trail within a finite graph, with each graph edge being visited precisely once. Thus, this already implies that the graph must be connected, where each node must be reachable, and undirected, where edges are non-oriented. 

\begin{lstlisting}[title={Graph definition.}, otherkeywords = {abstract, sig, module, set, fact, iden, no, in}]
module graph

abstract sig Node {
    adj : set Node
}

fact considerations {
    adj = ~adj
    no iden & adj
    Node->Node in *(adj + ~adj)
}
\end{lstlisting}

\subsubsection{Behaviour Representation}

\section{Structural Analysis}

Structural modelling only confers an conventional way of formally expressing the intended behaviour over a software component. To perform verification over the specified behaviour, it is advisable to implement analysis techniques, while supporting a illustrative way of exploring the behaviour through simulations. Alloy does not establish a clear process separation over the model design and property verification, meaning that model checking also accounts the model itself as property specification.

This section aims to explain how Alloy conducts system analysis, with further explanations over the corresponding analysis commands, along with an overview on the Alloy Analyzer interactive exploration over a system's design. Since system analysis rely on the reasonable implementation of Model-Checking techniques, the follwing section within this subject intends to cover both Bounded and Complete Model-Checking procedures, as the proper contextualization on this matter is highly important on understanding how Alloy's verification process works.

\subsection{Model Checking}

% Model-checking is increasingly popular in the early phases of the software development process. To establish the cor- rectness of a software design one must usually verify both structural and behavioral (or temporal) properties. Unfor- tunately, most specification languages, and accompanying model-checkers, excel only in analyzing either one or the other kind. This limits their ability to verify dynamic systems with rich configurations: systems whose state space is character- ized by rich structural properties, but whose evolution is also expected to satisfy certain temporal properties. To address this problem, we first propose Electrum, an extension of the Alloy specification language with temporal logic operators, where both rich configurations and expressive temporal properties can easily be defined. Two alternative model-checking techniques are then proposed, one bounded and the other unbounded, to verify systems expressed in this language, namely to verify that every desirable temporal property holds for every possible configuration.

Model Checking presents itself as a novel technique towards verifying temporal properties over the system finite-state, that is duly represented as a conclusive model. This technique is becoming highly used due to its importance as an early phase approach upon developing systems \cite{lwspecification}, as it confers the most valued ffunctionality over the analysing tools, which concrete models, regarding the software architecture, is exhaustively checked over behavioral properties. 



\subsection{System Analysis}
% Commands, Instances and Scopes

\subsection{Alloy Analyzer}


Model checking is the automatic process towards the verification if a given specification meets the system finite-state defined by a concrete model. In Electrum, unlike other analysis tools, there is a non-clear distinction between the model and the properties specification. By introduction of concrete abstraction processes and logic translations, the relational model specifications may be converted to model-checking prob- lems. There are two main categories of model-checkers that are included in the Electrum framework. Bounded model-checkers, which only consider computational traces with a limit number of distinct states, and unbounded ones, that discard this constraint. As previously referred, on the enunciation of the small scope hypothesis, bounded model- checkers are ideal to be used in the early states of analysis. They are able to produce quick feedback’s, and the majority of bugs are identified through small counter-examples. However, although bounded model-checking techniques can achieve much higher coverage levels than standard testing, they are still not complete, covering only an infimus part of every possible case. Thus, after the model under analysis has been validated, unbounded model-checkers can complement the analysis process by offering high-levels of reliability, towards verification.

To enable the use of both techniques, the Electrum architecture (Figure 5) was built follow- ing the same principles as in Alloy. The Electrum Analyzer is implemented on top of the Alloy Analyzer, and relies on the Pardinus model-finder, which was built upon KodKod [36]. An Electrum specification might be seen as FOLTL [3][14] logic’s with structure. However, the Pardinus only uses FOLTL logic’s. Thus, a transformation is required. The main operation consists on removing all relational terms present in the Electrum Kernel formulas, replacing them with the corresponding FOLTL sub-formulas. When the interpretation is complete, the Pardinus has two distinct options. One is to practice model-checking through SAT solvers [6], while the other is to do it upon symbolic based model checkers (SMV [20]). The for- mer performs bounded-verification, while the latter supports both, bounded or unbounded verification. If the option is to execute model-checking through SAT, the traces must be made explicit. Thus, the FOLTL logic’s are expanded into FOL, and the Kodkod is used to interface with multiple SAT-solvers. When the aim is to execute model-checking upon SMV, the FOLTL logic’s are expanded into LTL, for later use of Electrod2. This tool compiles the LTL problems into SMV. In this work context it’s not relevant to understand the intermediates logic’s itself, or how they are converted between components. Thus, the following sub-sections will give a major focus on the Electrum options to perform verification. Namely, through bounded and unbounded model-checking techniques.